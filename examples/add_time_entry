#!perl
use v5.32;
use warnings;

use lib qw(lib);
use experimental qw(signatures);

use Clockify;
use Clockify::DateTime;

=head1 NAME

add_time_entry - create Clockify time entries

=head1 SYNOPSIS

	# Add an entry for today with start and end times, and message
	% add_time_entry 1230 1730 "This is what I did"

	# Add an entry for the 20th of this month, with start and end times, and message
	% add_time_entry 20T1230 1730 "This is what I did"

	# Add an entry for January 20, with start and end times, and message
	% add_time_entry 1-20T1230 1730 "This is what I did"

	# If the month is later than this month, it's last year
	% add_time_entry 12-20T1230 1730 "This is what I did"

=head1 DESCRIPTION

=cut

use Mojo::Util qw(dumper);

run( @ARGV ) unless caller;

sub run ( @args ) {
	my( $start, $end, $description ) = @args;

	my $user = Clockify->current_user;
	say "User ID: ", $user->id;
	say "Active Workspace ID: ", $user->active_workspace_id;

	my %query;

	$query{start}       = guess_datetime( $start ),
	$query{end}         = guess_datetime( $end, $query{start} ),
	$query{description} = $description;
	$query{project}     = $ENV{CLOCKIFY_PROJECT_ID};

	say dumper( \%query );
	print "Proceed? ";
	my $answer = <STDIN>;
	exit unless $answer =~ /\Ay/i;

	my $result = $user->add_time_entry( \%query );
	if( $result->is_success ) {
		say <<~"HERE";
		Added entry @{[ $result->id ]}
			@{[ $result->start_date ]}
			@{[ $result->end_date ]}

			@{ [ $result->duration->{elapsed_hours} ] } hours
		HERE
		}
	else {
		say <<~"HERE";
		Error code @{[ $result->code ]}
		@{[ $result->message ]}
		HERE
		}
	}



sub date_format( $year, $month, $day ) {
	sprintf "%4d-%02d-%02d", $year, $month, $day;
	}

sub datetime_format( $year, $month, $day, $hour, $minute ) {
	sprintf "%4d-%02d-%02dT%02d:%02d",
		$year, $month, $day, $hour, $minute;
	}
